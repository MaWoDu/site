panels:
  - id: por-que-asistir
    title: ¿Por qué asistir?
    content: training_content_why_attend.liquid
  - id: audiencia
    title: Audiencia
    content: training_content_audience.liquid
  - id: contenido-del-curso
    title: Contenido del curso
    content: training_content_course_content.liquid
  - id: prerequisitos
    title: Prerequisitos
    content: training_content_prerequisites.liquid

crafting-code-and-crafted-design:
  why-attend:
    intro: Software Craftsmanship es el corazón de este curso. A lo largo de este curso, tu equipo aprenderá sobre la mentalidad de Software Craftsmanship y cómo aplicarla dentro de la organización.
    clean-code-headline-one: Escribir Clean Code no es fácil; y limpiar código existente todavía menos.
    why-attend: "Tu equipo debe asistir si necesita:"
    why-attend-list:
      - Alinear la tecnología con los requerimientos del negocio
      - Escribir código limpio que sea fácil de entender y mantener
      - "Mejorar sus competencias en Test-Driven Development (TDD): usando testing para diseñar y construir"
    clean-code-headline-two: El código limpio requiere un buen diseño.
    learning-objectives-title: "Tu equipo aprenderá:"
    learning-objectives-list:
      - A comprender los principios de diseño que conducen a un código limpio.
      - A evitar la sobre-ingeniería y las grandes reescrituras mediante un diseño que evolucione gradualmente utilizando pruebas.
    learning-outcome: Una vez que tu equipo domine estos principios podrá aplicarlos a código heredado. Esto les permitirá ganar confianza trabajando con legacy code.
    software-design-intro: La parte de diseño de software de esta serie de capacitación se centra al nivel de aplicaciones y microservicios utilizando los requisitos comerciales para impulsar el diseño.
    application-title: "Aplicaciones:"
    application-list:
      - estructura interna
      - capas
      - componentes
      - mecanismo de entrega
      - core domain
    microservices-title: "Microservicios:"
    microservices-list:
      - definir la responsabilidad de cada servicio
      - cómo colaboran los servicios
      - visibilidad interna / externa

  audience:
    intro: "Este curso está diseñado para equipos de desarrollo de software:"
    list:
      - familiarizados con un nivel mínimo de lenguaje orientado a objetos.
      - con competencias en Java o C#
      - capaces de escribir y ejecutar pruebas unitarias utilizando un framework (como JUnit, NUnit, etc.)
      - con un comprensión básica de los  mock objects

  course-content:
    principles-intro: "Principios de:"
    list:
      - Test-Driven Development (TDD)
      - Object-Orientated Design (OOD)
      - Domain-Driven Design (DDD)
      - Interaction-Driven Design (IDD)
    content-intro: "Contenido:"
    second-list:
      - Ciclo de vida TDD y modelado de comportamientos
      - Escritura de pruebas unitarias que expresan intención, no implementación
      - Utilizando pruebas unitarias para conseguir un buen diseño.
      - Expressive code
      - Probar y refactorizar código heredado
      - Cómo estructurar proyectos para que expresen lo que hace la aplicación y de qué se trata
      - Comprender las diferencias entre capas, hexágonos, características y componentes
      - Identificación de servicios a partir de reglas comerciales
      - Expresar diseño y arquitectura en código, pero manteniendo claridad en el dominio
      - Comprender Impact Mapping como técnica y cómo se puede derivar una arquitectura de servicios a partir de ella

  prerequisites:
    intro: Se trata de un curso totalmente práctico, así que se requerirá que los equipos de desarrollo de software escriban mucho código.
    required: "Necesario:"
    list:
      - Tener disponible tu propio ordenador portátil
      - Ser capaz de crear proyectos, construir código fuente y ejecutar casos de prueba en su entorno de desarrollo
      - "Tener un entorno de desarrollo que conste de lo siguiente:"
      - Se recomienda un sistema de control de versiones distribuido como por ejemplo Github
    second-list:
      - Lenguaje orientado a objetos
      - Un framework the unit testing
      - Una librería para hacer mocking


crafted-design:
  why-attend:
    intro: Este curso aborda el diseño desde un nivel micro hasta microservicios utilizando Test-Driven Development. Con esta formación los equipos podrán mejorar su capacidad para diseñar software que responda, tanto a las necesidades a menudo muy variables del negocio, como a requsitos nuevos que se planteen, solventando  dificultades derivadas de legacy code.
    learning-objectives-title: "Este curso aporta a los equipos de desarrollo de software conocimientos sobre:"
    learning-objectives-list:
      - Técnicas de diseño que se pueden aplicar a situaciones del mundo real
      - Aplicar arquitectura de microservicios para dar respuesta a las necesidades del negocio
      - Cómo mantener un diseño limpio a medida que la aplicación crece y los requisitos comerciales cambian
      - Construir software que es independiente de la tecnología
      - Comportamiento del modelo en lugar de estado manteniendo un diseño alineado con los objetivos del negocio

  audience:
    intro: "Este curso está pensado para equipos de desarrollo de software que:"
    list:
      - Cuenten con al menos dos años de experiencia en desarrollo de software con fines comerciales
      - Estén familiriarizados con algún lenguaje orientado a objetos, como Java, C# o C++
      - Se sientan cómodos usando TDD para construir software
      - Entiendan mock objects y cómo utlizar una mocking library
      - Tengan una comprensión general de los diferentes estilos arquitectónicos, incluidos los microservicios

  course-content:
    principles-intro: "Principios de:"
    list:
      - Los dos estilos principales de diseño Test-Driven Design (Classicist and Outside-In)
      - Object-Orientated Design (OOO)
      - Domain-Driven Design (DDD)
      - Interaction-Driven Design (IDD)
      - Balanced Abstraction Principle (BAP)
    content-intro: "Contenido:"
    second-list:
      - Escritura de pruebas unitarias que expresan intención, no implementación
      - Diseño emergente a través del TDD Classicist
      - TDD como herramienta de diseño Outside-In style
      - Comandos, consultas y cumplimiento de Open/Close Principle
      - Diferencias entre capas, hexágonos, características y componentes
      - Estructurar proyectos para que expresen lo que hace la aplicación y de qué se trata
      - Comportamiento de modelado utilizando Outside-In Design
      - Identificación de servicios a partir de reglas de negocio
      - Expressive design y arquitectura en código manteniendo su dominio claro
      - Comprender Impact Mapping y cómo derivar hacia una arquitectura de servicios a partir de él

  prerequisites:
    intro: Recomendamos encarecidamente que los equipos de desarrollo de software realicen primero el curso sobre Crafting Code para aprovechar mejor los contenidos de este curso. No se trata de un curso introductorio a Test-Driven Development  y sin una comprensión sólida pueden tener dificultades para seguirlo.
    required: "Necesario:"
    list:
      - Tener disponible tu propio ordenador portátil
      - Aplicar habitualmente TDD  en proyectos
      - Capacidad para crear proyectos, pruebas y códigos y ejecutarlos en su entorno local
      - Se recomienda un sistema de control de versiones distribuido como por ejemplo Github
